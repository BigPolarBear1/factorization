Note: I am antifa, leader of the cipherpunk, fuck the FBI department. 

#### To run from folder "QS_variant" (Standard SIQS with our number theory as backend):</br></br>
To build: python3 setup.py build_ext --inplace</br>
To run: python3 run_qs.py -keysize 200 -base 6000 -debug 1 -lin_size 100_000 -quad_size 1</br></br>
This version is somewhat done, but it doesn't achieve much of an advantage, as the main strength of my work will be the NFS_Variant, which performs NFS with reducible quadratic polynomials<br><br>
#### To run from folder "NFS_variant" (Number Field Sieve with our number theory as backend using reducible quadratic polynomials mod m):</br></br>
To run: python3 polarbearalg_v04 -key 4387 (The debug versions are just for the math in the paper in the final chapter.. I'll rewrite that final chapter one last time once the code is fully done)</br></br>
The files in this folder, relate to my work of my own (better) variant on number field sieve... this is a work in progress</br></br>

I have also uploaded polarbearalg_v05. v04 works fully in the integers on both side of the congruence. v05 converts the bigger side to an algebraic one. However, the linear algebra step in v05 is failing now, because it also needs a quadratic character base (i.e you just take the coefficient y0 and calculate jacobi((y0^2-n\*4\*z),prime). That should force square relations with some multiple of N inbetween.... if you don't do that, the linear algebra step will just yield two squares smaller then N.... which we don't want. Additionally, you may also have to take a square root over a finite field then... but I'll have to check how to do that once my quadratic character base is implemented, I have some ideas how that would work though. 

Update: I ended up looking some more. I implemented code for the quadratic character base. Tomorrow I will just need to dive in now. The good thing is, if I know the roots and coefficients for the side where we find a square in the integers ... then I also know what the correct solution should be (coefficients and root) for the other square. So I know I'll need to perform some math, to go from what the algebraic side is spitting out to the correct one. And I also remember from earlier, last month, where I was experimenting with square multiples of a smooth, and how it allowed me to adjust the coefficients ... I suspect I can do something similar to that by just finding a square on the algebraic side. That's what my intuition is telling me atleast. Anyway, I got it all set up for tomorrow now to figure out this very last part. And once that happens, that's it. I'll be able to finish my code within the hour..... upload it...and boom, game over. The moment I figure out this last part, it's game over. Lets get some sleep first... I need to be able to think straight for this and go at it for a couple of hours non-stop.

First thing tomorrow, that trick I was doing last month with square multiples. I just need to figure out how I can use something similar in the context of what I'm doing now. Because that was basically finding a square mod m, adjusting the coefficients and taking the GCD. And finding a square mod m, that's exactly what the algebraic side does. There must be some correlation there, something I can leverage to finish my work now. I often curse myself for having wasted so much time on detours, but looking at the larger picture... everything I learned in those detours, it all fits into this bigger picture, which I needed to see more clearly to finish this final step of my work. So I probably wasn't yet at the maturity needed to finish this late last spring, even though I got really close to what I'm currently doing, I was still missing all these little things I learned going on detours into SIQS and all that. So I shouldn't see it as time lost. And once this is done, and I attack ECC... I'll have so much knowledge, like actual hands-on knowledge, to leverage instantly already.

note to self: Tomorrow I should open that old QSv3_Find_Similar.pyx PoC..then find some examples of square multiples of a smooth, and look at what is going on with the polynomials (not just discriminant) ... and then hopefully I can reverse engineer that mechanic to make it useful for what I'm doing now, and use it to complete the last step. 1 am late night contemplating math is the best. If you want to be a good researcher, when you end the day, just stare at the ceiling and think about the problem you are trying to solve, and then write down ideas to try out the next day. Thats my special research ingredient. Hahahahahahhahaha.
